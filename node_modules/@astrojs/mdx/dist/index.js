import { markdownConfigDefaults } from "@astrojs/markdown-remark";
import { toRemarkInitializeAstroData } from "@astrojs/markdown-remark/dist/internal.js";
import { compile as mdxCompile } from "@mdx-js/mdx";
import mdxPlugin from "@mdx-js/rollup";
import { parse as parseESM } from "es-module-lexer";
import fs from "node:fs/promises";
import { VFile } from "vfile";
import { getRehypePlugins, getRemarkPlugins, recmaInjectImportMetaEnvPlugin } from "./plugins.js";
import { getFileInfo, parseFrontmatter } from "./utils.js";
function mdx(partialMdxOptions = {}) {
  return {
    name: "@astrojs/mdx",
    hooks: {
      "astro:config:setup": async ({ updateConfig, config, addPageExtension, command }) => {
        addPageExtension(".mdx");
        const extendMarkdownConfig = partialMdxOptions.extendMarkdownConfig ?? defaultOptions.extendMarkdownConfig;
        const mdxOptions = applyDefaultOptions({
          options: partialMdxOptions,
          defaults: extendMarkdownConfig ? config.markdown : defaultOptions
        });
        const mdxPluginOpts = {
          remarkPlugins: await getRemarkPlugins(mdxOptions, config),
          rehypePlugins: getRehypePlugins(mdxOptions),
          recmaPlugins: mdxOptions.recmaPlugins,
          remarkRehypeOptions: mdxOptions.remarkRehype,
          jsx: true,
          jsxImportSource: "astro",
          format: "mdx",
          mdExtensions: []
        };
        let importMetaEnv = {
          SITE: config.site
        };
        updateConfig({
          vite: {
            plugins: [
              {
                enforce: "pre",
                ...mdxPlugin(mdxPluginOpts),
                configResolved(resolved) {
                  importMetaEnv = { ...importMetaEnv, ...resolved.env };
                },
                async transform(_, id) {
                  if (!id.endsWith("mdx"))
                    return;
                  const { fileId } = getFileInfo(id, config);
                  const code = await fs.readFile(fileId, "utf-8");
                  const { data: frontmatter, content: pageContent } = parseFrontmatter(code, id);
                  const compiled = await mdxCompile(new VFile({ value: pageContent, path: id }), {
                    ...mdxPluginOpts,
                    remarkPlugins: [
                      toRemarkInitializeAstroData({ userFrontmatter: frontmatter }),
                      ...mdxPluginOpts.remarkPlugins ?? []
                    ],
                    recmaPlugins: [
                      ...mdxPluginOpts.recmaPlugins ?? [],
                      () => recmaInjectImportMetaEnvPlugin({ importMetaEnv })
                    ]
                  });
                  return {
                    code: escapeViteEnvReferences(String(compiled.value)),
                    map: compiled.map
                  };
                }
              },
              {
                name: "@astrojs/mdx-postprocess",
                transform(code, id) {
                  if (!id.endsWith(".mdx"))
                    return;
                  const [moduleImports, moduleExports] = parseESM(code);
                  const importsFromJSXRuntime = moduleImports.filter(({ n }) => n === "astro/jsx-runtime").map(({ ss, se }) => code.substring(ss, se));
                  const hasFragmentImport = importsFromJSXRuntime.some(
                    (statement) => /[\s,{](Fragment,|Fragment\s*})/.test(statement)
                  );
                  if (!hasFragmentImport) {
                    code = 'import { Fragment } from "astro/jsx-runtime"\n' + code;
                  }
                  const { fileUrl, fileId } = getFileInfo(id, config);
                  if (!moduleExports.includes("url")) {
                    code += `
export const url = ${JSON.stringify(fileUrl)};`;
                  }
                  if (!moduleExports.includes("file")) {
                    code += `
export const file = ${JSON.stringify(fileId)};`;
                  }
                  if (!moduleExports.includes("Content")) {
                    code = code.replace("export default MDXContent;", "");
                    code += `
export const Content = (props = {}) => MDXContent({
											...props,
											components: { Fragment, ...props.components },
										});
										export default Content;`;
                  }
                  code += `
Content[Symbol.for('astro.needsHeadRendering')] = !Boolean(frontmatter.layout);`;
                  if (command === "dev") {
                    code += `
if (import.meta.hot) {
											import.meta.hot.decline();
										}`;
                  }
                  return escapeViteEnvReferences(code);
                }
              }
            ]
          }
        });
      }
    }
  };
}
const defaultOptions = {
  ...markdownConfigDefaults,
  extendMarkdownConfig: true,
  recmaPlugins: [],
  remarkPlugins: [],
  rehypePlugins: [],
  remarkRehype: {}
};
function applyDefaultOptions({
  options,
  defaults
}) {
  return {
    syntaxHighlight: options.syntaxHighlight ?? defaults.syntaxHighlight,
    extendMarkdownConfig: options.extendMarkdownConfig ?? defaults.extendMarkdownConfig,
    recmaPlugins: options.recmaPlugins ?? defaults.recmaPlugins,
    remarkRehype: options.remarkRehype ?? defaults.remarkRehype,
    gfm: options.gfm ?? defaults.gfm,
    smartypants: options.smartypants ?? defaults.smartypants,
    remarkPlugins: options.remarkPlugins ?? defaults.remarkPlugins,
    rehypePlugins: options.rehypePlugins ?? defaults.rehypePlugins,
    shikiConfig: options.shikiConfig ?? defaults.shikiConfig
  };
}
function escapeViteEnvReferences(code) {
  return code.replace(/import\.meta\.env/g, "import\\u002Emeta.env");
}
export {
  mdx as default
};
